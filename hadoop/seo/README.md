# Задача 

Вам даны пары <запрос, URL>, вам необходимо найти лучший запрос к каждому хосту. Напомню что, хост эта часть схемы URL: протокол://хост[:порт]/путь?параметры

На семинаре мы начали рассматривать задачу о метеостанциях в качестве примера использования вторичной сортировки. Рекомендую детально доразобрать эту задачу перед тем как приступить к ДЗ.

Напомню, Hadoop не сортирует значения, и для решения "в лоб" нам необходимо держать все запросы соответствующие данному хосту в памяти. И разнообразие запросов к определенным хостам, таким как ru.wikipedia.org или otvet.mail.ru может сделать это проблемным.

Поэтому необходимо использовать композитный ключ.

Предобработаные логи запросов находятся в /data/hw2/clicks/*/*.gz
Формат: запрос URL (разделенные табуляцией)


# Запуск

Используется ключ (хост, запрос).
Разбивается на partition'ы (уходит на разные Reducer'ы) по hash от хоста.
Группы для одного запуска метода reduce в Reducer'е собираются по хосту.
Порядок ключей, сгруппированных для одного запуска reduce, задаётся его compareTo. Так что значения частоты для одного запроса будут идти подряд, что упрощает подсчёт общеё частоты запроса для хоста в reducer'е упрощается. (Да, там меняется key, когда мы проходим по values! ?!?!??!?!?!??!!?) 

`hadoop jar hw2_seo/QueryCounter.jar /data/hw2/clicks/*/*.gz hw2_seo/best_queries`

Для тестирования:
`hadoop jar hw2_seo/QueryCounter.jar /data/hw2/clicks/2016.08.06/part-01.gz hw2_seo/test/best_queries`

Использование опции seo.minclicks=N, чтобы выводить лишь достаточно популярные запросы к хосту, повторяющиеся >= N раз

`hadoop jar hw2_seo/QueryCounter.jar -D seo.minclicks=2 /data/hw2/clicks/*/*.gz hw2_seo/best_queries_minclicks2`

Для тестирования:

`hadoop jar hw2_seo/QueryCounter.jar -D seo.minclicks=2 /data/hw2/clicks/2016.08.06/part-01.gz hw2_seo/test/best_queries_minclicks2`

HostLister и PartitonCreater не используются в решении, это заготовки для:


# Если я когда-нибудь доделаю красивый Partitioner

(Я хотела использовать TotalOrderPartitioner для более равномерного разбиения по partition'ам, но не осознала сразу, что sampler собирает статистику по ключам во входных данных, а не по выводу mappera, так что нужно ещё и для приведения входных данных к нашему композитному ключу input format писать)

Сначала запускается HostLister.jar. Mapper перечисляет хосты с преобразованием к формату нашего композитного ключа, чтобы по этому списку можно было собрать статистику для разбиения хостов по partition'ам.

`hadoop jar hw2_seo/HostLister.jar /data/hw2/clicks/*/*.gz hw2_seo/listed_hosts`

Для тестирования HostLister.jar: 

`hadoop jar hw2_seo/HostLister.jar /data/hw2/clicks/2016.08.06/part-01.gz hw2_seo/test/listed_hosts`









